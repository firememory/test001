!function (a) { var b = function (a, b) { var c = d(this, a, b); return c.extend = this.extend, c }, c = function () { }, d = function (b, d, e) { var f; return f = d && d.hasOwnProperty("constructor") ? d.constructor : function () { return b.apply(this, arguments) }, a.extend(f, b), c.prototype = b.prototype, f.prototype = new c, d && a.extend(f.prototype, d), e && a.extend(f, e), f.prototype.constructor = f, f.__super__ = b.prototype, f }, e = 0, f = ["el", "ctx"]; a.uniqueId = function (a) { var b = e++; return a ? a + b : b }, a.log = function () { window.console && console.log.apply(console, arguments) }, Graphic = function (b) { this.cid = a.uniqueId("view"), this.data = {}, this._configure(b || {}), this.initialize.apply(this, arguments) }, Graphic.prototype = { _configure: function (b) { var c, d, e, g; for (this.options && (b = a.extend({}, this.options, b)), c = 0, d = f.length; d > c; c++) e = f[c], b[e] && (this[e] = b[e]); this.options = b, this.el && "string" == typeof this.el && (g = a(this.el), this.el = g.get(0), this.el && this.el.getContext && (this.ctx = this.el.getContext("2d"))) }, initialize: function () { }, render: function () { }, refresh: function () { }, setData: function (a) { this.data = a }, getData: function () { return this.data }, getCanvasContext: function () { return this.ctx }, getCanvasOffset: function () { return a(this.el).offset() }, pushData: function () { }, popData: function () { var a = this.data.items.pop(); return a } }, Painter = function (a, b) { this.ctx = a, this.options = b, this.maxDiff = 0, this.minDiff = 1e11, this.maxVolume = 0, this.initialize.apply(this, arguments) }, Painter.prototype = { initialize: function () { }, paint: function (a) { if (a && (this.data = a), this.ctx && this.data && this.options) { this.paintStart(); try { this.paintItems() } catch (b) { } this.paintEnd() } }, paintStart: function () { this.ctx.beginPath() }, paintItems: function () { var b, c, f, a = this.getDataLength(), d = 0, e = this.getMaxPaintItemsLength(); for (d = a > e ? a - e : 0, f = d; a > f; f++) b = this.getX(f - d), c = this.getY(f), this.paintItem(f, b, c) }, paintItem: function () { }, paintEnd: function () { this.ctx.stroke() }, getX: function () { return 0 }, getY: function () { return 0 }, getItems: function () { return this.data.items || [] }, getItemValue: function (a) { return this.data.items[a] ? this.data.items[a].newPrice : 0 }, getItemAverageValue: function (a) { return this.data.items[a] ? this.data.items[a].average : 0 }, getItemVolume: function (a) { return this.data.items[a] ? this.data.items[a].volume : 0 }, getDataLength: function () { return this.getItems().length }, getMiddleValue: function () { return this.data.stockData.zs }, getItemHighValue: function (a) { return this.data.items[a].high }, getItemLowValue: function (a) { return this.data.items[a].low }, getItemStartValue: function (a) { return this.data.items[a].open }, getItemEndValue: function (a) { return this.data.items[a].close }, getLowerLimitValue: function () { return this.data.stockData.lowerLimit }, getHighLimitValue: function () { return this.data.stockData.upperLimit }, getItemMACD: function (a) { return this.data.items[a].MACD }, getItemKDJ: function (a) { return this.data.items[a].KDJ }, getItemRSI: function (a) { return this.data.items[a].RSI }, getItemDMA: function (a) { return this.data.items[a].DMA }, getMaxPaintItemsLength: function () { var c, a = this.options, b = 1; return "undefined" != typeof a.width ? c = Math.floor((a.region.width - 2 * b) / (a.width + 2 * a.splitSpace)) : a.maxDots || this.getDataLength() || 0 } }, Graphic.extend = Painter.extend = b }(Zepto), function () { var c = function (a, b, c, d) { var f, e = 0; if (c > b) { for (f = 0; b >= f; f++) e += Number(a[f][d]); return e / (b + 1) } for (f = b; f > b - c; f--) e += Number(a[f][d]); return e / c }; LinePainter = Painter.extend({ initialize: function () { }, paintStart: function () { var a = this.options, b = a.region, c = this.ctx; c.save(), c.translate(b.x, b.y + b.height / 2), this.setMaxDiff(), c.beginPath(), c.strokeStyle = a.priceLineColor, c.lineJoin = "round" }, setMaxDiff: function () { var a, f, g, b = this.getItems(), c = this.options; for (c.region, this.ctx, g = 0; g < b.length; g++) this.getItemValue(g) > 0 && (a = Math.abs(this.getMiddleValue() - this.getItemValue(g)), this.maxDiff = Math.max(a, this.maxDiff)); 0 == this.maxDiff && (this.maxDiff = .1 * this.getMiddleValue() + 1), this.maxDiff += this.maxDiff / (c.horizontalLineCount + 1), this.getHighLimitValue() && (f = this.getHighLimitValue() - this.getMiddleValue(), this.maxDiff = Math.min(f, this.maxDiff)) }, paintItem: function (a, b, c) { 0 === a && c !== !1 ? (this.getY(a + 1) === !1 && this.ctx.arc(b, c, .5, 0, 2 * Math.PI), this.ctx.moveTo(b, c)) : c !== !1 && this.getY(a - 1) !== !1 ? this.ctx.lineTo(b, c) : c !== !1 ? (this.getY(a + 1) === !1 && this.ctx.arc(b, c, .5, 0, 2 * Math.PI), this.ctx.moveTo(b, c)) : (this.ctx.stroke(), this.ctx.beginPath()) }, paintEnd: function () { var a = this.ctx; a.stroke(), a.restore() }, getX: function (a) { var b = this.options, c = 1; return Math.round(a * ((b.region.width - 2 * c) / (b.maxDots - 1))) + c - 1 }, getY: function (a) { var b = this.options, c = this.getItemValue(a) - this.getMiddleValue(); return isNaN(this.getItemValue(a)) || Math.abs(c) > Math.abs(this.maxDiff) || 0 === this.getItemValue(a) ? !1 : -(c / this.maxDiff * (b.region.height / 2)) } }), AverageLinePainter = LinePainter.extend({ getY: function (a) { var b = this.options, c = this.getItemAverageValue(a) - this.getMiddleValue(); return isNaN(this.getItemAverageValue(a)) || Math.abs(c) > Math.abs(this.maxDiff) || 0 === this.getItemValue(a) ? !1 : -(c / this.maxDiff * (b.region.height / 2)) } }), MountainLinePainter = LinePainter.extend({ paintStart: function () { var a = this.options, b = a.region, c = this.ctx; c.save(), c.translate(b.x, b.y + b.height / 2), this.setMaxDiff(), c.beginPath(), c.strokeStyle = a.priceLineColor, c.fillStyle = a.MountainFillColor, c.globalAlpha = a.MountainFillAlpha, c.lineJoin = "round" }, paintItem: function (a, b, c) { var d = this.options, e = this.ctx, f = this.getY(a - 1), g = this.getY(a + 1); c !== !1 && f === !1 && g === !1 ? e.arc(b, c, .5, 0, 2 * Math.PI) : c !== !1 && f === !1 ? (e.moveTo(b, c), this.startPos = [b, c]) : c !== !1 && g === !1 ? (e.lineTo(b, c), e.globalAlpha = 1, e.stroke(), e.lineTo(b, d.region.height / 2), e.lineTo(this.startPos[0], d.region.height / 2), e.lineTo(this.startPos[0], this.startPos[1]), e.globalAlpha = d.MountainFillAlpha, e.fill(), e.beginPath()) : c !== !1 && e.lineTo(b, c) } }), KLinePainter = Painter.extend({ initialize: function () { }, paintStart: function () { var c = (this.getItems(), this.options), d = c.region, e = this.ctx; e.save(), e.translate(d.x, d.y + d.height), e.beginPath(), e.strokeStyle = c.volLineColor, e.lineJoin = "round" }, paintItem: function (a, b, c) { 0 === a ? this.ctx.moveTo(b, -c) : this.ctx.lineTo(b, -c) }, paintEnd: function () { var a = this.ctx; a.stroke(), a.restore() }, getX: function (a) { var b = this.options; return Math.round(a * (2 * b.splitSpace + b.width) + b.splitSpace + b.width / 2) + .5 }, getY: function (a) { function h(a, b, c, d) { var f, g, e = 0; if (f = d ? "close" : "volume", c > b) { for (g = 0; b >= g; g++) e += Number(a[g][f]); return e / (b + 1) } for (g = b; g > b - c; g--) e += Number(a[g][f]); return e / c } var g, b = this.options, c = b.maxVolume || b.maxDiff, d = b.minDiff || 0, e = b.splitDay, f = this.data; return b.priceLine ? (g = h(f.items, a, e, b.priceLine), a == f.items.length - 1 && (f.items[a]["MA" + e] = g), columnHeight = (g - d) / (c - d) * b.region.height) : columnHeight = h(f.items, a, e, b.priceLine) / c * b.region.height, columnHeight } }), TechnicalLinePainter = Painter.extend({ paintStart: function () { var c = (this.getItems(), this.options), e = (this.options.region, this.ctx); e.save(), this.maxAbsTechnicalDiff = c.maxAbsTechnicalDiff || 0, this.maxTechnicalDiff = c.maxTechnicalDiff || 0, this.minTechnicalDiff = c.minTechnicalDiff || 0, e.strokeStyle = 0 == c.lineType ? c.curveLineColor1 : 1 == c.lineType ? c.curveLineColor2 : c.curveLineColor3, "MACD" == c.technicalAnalysis || "DMA" == c.technicalAnalysis ? e.translate(c.region.x, c.region.y + c.region.height / 2) : ("KDJ" == c.technicalAnalysis || "RSI" == c.technicalAnalysis) && e.translate(c.region.x, c.region.y + c.region.height - c.topAndBottomSpace), e.beginPath(), e.lineJoin = "round" }, paintItem: function (a, b, c) { 0 === a ? this.ctx.moveTo(b, c) : this.ctx.lineTo(b, c) }, paintEnd: function () { var a = this.ctx; a.stroke(), a.restore() }, getX: function (a) { var b = this.options; return Math.round(a * (2 * b.splitSpace + b.width) + b.splitSpace + b.width / 2) }, getY: function (a) { var f, e, b = this.options; switch (this.getDataLength(), this.getItems(), e = null, b.technicalAnalysis) { case "MACD": e = this.getItemMACD(a)[b.lineType] || 0, f = -((b.region.height / 2 - b.topAndBottomSpace) / this.maxAbsTechnicalDiff * e); break; case "KDJ": e = this.getItemKDJ(a)[b.lineType] || 0, f = -((b.region.height - 2 * b.topAndBottomSpace) / (this.maxTechnicalDiff - this.minTechnicalDiff) * (e - this.minTechnicalDiff)); break; case "RSI": e = this.getItemRSI(a)[b.lineType] || 0, f = -((b.region.height - 2 * b.topAndBottomSpace) / (this.maxTechnicalDiff - this.minTechnicalDiff) * (e - this.minTechnicalDiff)); break; case "DMA": e = this.getItemDMA(a)[b.lineType] || 0, f = -((b.region.height / 2 - b.topAndBottomSpace) / this.maxAbsTechnicalDiff * e) } return f } }), VolumePainter = Painter.extend({ paintStart: function () { var a, e, b = this.getItems(), c = this.options.region, d = this.ctx; for (d.save(), d.translate(c.x, c.y + c.height), e = 0; e < b.length; e++) a = this.getItemVolume(e), this.maxVolume = Math.max(a, this.maxVolume) }, paintItem: function (a, b, c) { var d = this.ctx, e = this.options; d.beginPath(), d.moveTo(b, 0), d.lineTo(b, -c), d.strokeStyle = this.getItemValue(a) > this.getMiddleValue() ? e.riseColor : this.getItemValue(a) < this.getMiddleValue() ? e.fallColor : e.equalColor, d.stroke() }, paintEnd: function () { this.ctx.restore() }, getX: function (a) { var b = this.options, c = 1; return Math.round(a * ((b.region.width - 2 * c) / (b.maxDots - 1))) + c }, getY: function (a) { var b = this.options, c = this.maxVolume, d = this.getItemVolume(a) / c * b.region.height; return d } }), DealVolumePainter = VolumePainter.extend({ paintStart: function () { var a, f, g, h, i, b = this.getItems(), d = this.options.region, e = this.ctx; for (e.save(), e.translate(d.x, d.y + d.height), f = b.length - this.getMaxPaintItemsLength(), f = 0 > f ? 0 : f, g = f + 5 - 2 > b.length - 1 ? b.length - 1 : f + 5 - 2, h = f; g >= h; h++) i = c(b, h, 5, "volume"), this.maxVolume = Math.max(i, this.maxVolume); for (g = f + 10 - 2 > b.length - 1 ? b.length - 1 : f + 10 - 2, h = f; g >= h; h++) i = c(b, h, 10, "volume"), this.maxVolume = Math.max(i, this.maxVolume); for (g = f + 20 - 2 > b.length - 1 ? b.length - 1 : f + 20 - 2, h = f; g >= h; h++) i = c(b, h, 20, "volume"), this.maxVolume = Math.max(i, this.maxVolume); for (h = f; h < b.length; h++) a = this.getItemVolume(h), this.maxVolume = Math.max(a, this.maxVolume) }, paintItem: function (a, b, c) { var d = this.ctx, f = this.options; d.beginPath(), this.getItemStartValue(a) < this.getItemEndValue(a) ? (d.fillStyle = f.riseColor, d.strokeStyle = f.riseColor) : this.getItemStartValue(a) > this.getItemEndValue(a) ? (d.fillStyle = f.fallColor, d.strokeStyle = f.fallColor) : (d.fillStyle = f.equalColor, d.strokeStyle = f.equalColor), 0 == this.getItemVolume(a) ? (d.moveTo(b - Math.ceil(f.width / 2), c), d.lineTo(b + Math.floor(f.width / 2), c)) : d.fillRect(b - Math.ceil(f.width / 2), -c, f.width, c), d.stroke() }, getX: function (a) { var b = this.options; return Math.round(a * (2 * b.splitSpace + b.width) + b.splitSpace + b.width / 2) } }), MACDHistogramPainter = DealVolumePainter.extend({ paintStart: function () { var c = (this.getItems(), this.options), e = (this.options.region, this.ctx); e.save(), e.translate(c.region.x, c.region.y + c.region.height / 2), this.maxAbsTechnicalDiff = c.maxAbsTechnicalDiff || 0 }, paintItem: function (a, b, c) { var d = this.ctx, e = this.options; d.beginPath(), d.moveTo(b, 0), d.lineTo(b, c), d.strokeStyle = 0 > c ? e.riseColor : c > 0 ? e.fallColor : e.equalColor, d.stroke() }, getY: function (a) { var b = this.options; return this.getDataLength(), this.getItems(), -((b.region.height / 2 - b.topAndBottomSpace) / this.maxAbsTechnicalDiff * this.getItemMACD(a)[2]) } }), CandlePainter = Painter.extend({ paintStart: function () { var a = this.options, b = a.region, c = this.ctx; c.save(), c.translate(b.x, b.y + b.height), this.setDiff() }, setDiff: function () { var a, g, h, j, k, b = this.getItems(), d = this.options; for (d.region, this.ctx, g = b.length - this.getMaxPaintItemsLength(), g = 0 > g ? 0 : g, h = g + 5 - 2 > b.length - 1 ? b.length - 1 : g + 5 - 2, j = g; h >= j; j++) k = c(b, j, 5, "close"), this.maxDiff = Math.max(k, this.maxDiff), this.minDiff = Math.min(k, this.minDiff); for (h = g + 10 - 2 > b.length - 1 ? b.length - 1 : g + 10 - 2, j = g; h >= j; j++) k = c(b, j, 10, "close"), this.maxDiff = Math.max(k, this.maxDiff), this.minDiff = Math.min(k, this.minDiff); for (h = g + 20 - 2 > b.length - 1 ? b.length - 1 : g + 20 - 2, j = g; h >= j; j++) k = c(b, j, 20, "close"), this.maxDiff = Math.max(k, this.maxDiff), this.minDiff = Math.min(k, this.minDiff); for (j = g; j < b.length; j++) a = this.getItemHighValue(j), lowest = this.getItemLowValue(j), this.maxDiff = Math.max(a, this.maxDiff), this.minDiff = Math.min(lowest, this.minDiff) }, paintItem: function (a, b, c) { var d = this.ctx, e = this.options; d.beginPath(), this.getItemStartValue(a) > this.getItemEndValue(a) ? (d.fillStyle = e.fallColor, d.strokeStyle = e.fallColor) : this.getItemStartValue(a) < this.getItemEndValue(a) ? (d.fillStyle = e.riseColor, d.strokeStyle = e.riseColor) : (d.fillStyle = e.equalColor, d.strokeStyle = e.equalColor), d.lineWidth = "1px", c[0] < c[1] ? (d.fillRect(b - Math.ceil(e.width / 2), c[0], e.width, c[1] - c[0]), c[2] < c[0] && (d.moveTo(b - .5, c[0]), d.lineTo(b - .5, c[2])), c[1] < c[3] && (d.moveTo(b - .5, c[1]), d.lineTo(b - .5, c[3]))) : (c[0] == c[1] ? (d.moveTo(b - Math.ceil(e.width / 2), c[1]), d.lineTo(b + Math.floor(e.width / 2), c[1])) : d.fillRect(b - Math.ceil(e.width / 2), c[1], e.width, c[0] - c[1]), c[2] < c[1] && (d.moveTo(b - .5, c[1]), d.lineTo(b - .5, c[2])), c[0] < c[3] && (d.moveTo(b - .5, c[0]), d.lineTo(b - .5, c[3]))), d.stroke() }, paintEnd: function () { this.ctx.restore() }, getX: function (a) { var b = this.options; return Math.round(a * (2 * b.splitSpace + b.width) + b.splitSpace + b.width / 2) + .5 }, getY: function (a) { var b = this.options, c = this.getItemStartValue(a), d = this.getItemEndValue(a), e = this.getItemHighValue(a), f = this.getItemLowValue(a), g = b.region.height; return [-(Math.round((c - this.minDiff) / (this.maxDiff - this.minDiff) * g) + .5), -(Math.round((d - this.minDiff) / (this.maxDiff - this.minDiff) * g) + .5), -(Math.round((e - this.minDiff) / (this.maxDiff - this.minDiff) * g) + .5), -(Math.round((f - this.minDiff) / (this.maxDiff - this.minDiff) * g) + .5)] } }), yAxis = Painter.extend({ paintStart: function () { var a = this.ctx, b = this.options; a.save(), a.font = b.font, a.translate(b.region.x, b.region.y), a.textBaseline = b.textBaseline }, paintItem: function (a, b, c) { var d = this.ctx; d.fillStyle = this.options.color || this.getTextColor(a), d.fillText(this.data[a], b, c) }, paintItems: function () { var b, c, e, a = this.getDataLength(), d = 0; for (e = d; a > e; e++) b = this.getX(e - d), c = this.getY(e), e == a - 1 && (c -= 10), this.paintItem(e, b, c) }, paintEnd: function () { this.ctx.restore() }, getX: function (a) { var c, b = this.options; return "left" == b.align ? 6 : (c = this.ctx.measureText(this.data[a]).width, b.region.width - c - 10) }, getY: function (a) { var b = this.options, c = this.getDataLength(); return 0 == a ? 0 : a == c - 1 ? b.region.height - b.fontHeight : b.region.height * a / (c - 1) - b.fontHeight / 2 }, getItems: function () { return this.data }, getTextColor: function (a) { var b = parseInt(this.getDataLength() / 2, 10), c = this.options; return b > a ? c.riseColor : a == b ? c.normalColor : c.fallColor } }), yAxisTechnical = Painter.extend({ paintStart: function () { var a = this.ctx, b = this.options; a.save(), a.font = b.font, this.maxAbsTechnicalDiff = b.maxAbsTechnicalDiff || 0, this.maxTechnicalDiff = b.maxTechnicalDiff || 0, this.minTechnicalDiff = b.minTechnicalDiff || 0, this.level = "KDJ" == b.technicalAnalysis ? 100 : 1e3, "MACD" == b.technicalAnalysis || "DMA" == b.technicalAnalysis ? a.translate(b.region.x, b.region.y + b.region.height / 2) : ("KDJ" == b.technicalAnalysis || "RSI" == b.technicalAnalysis) && a.translate(b.region.x, b.region.y + b.region.height - b.topAndBottomSpace), a.textBaseline = b.textBaseline }, paintItem: function (a, b, c) { var d = this.ctx; c !== !1 && (d.fillStyle = this.options.color || this.getTextColor(a), d.fillText(100 * (this.data[a] / this.level).toFixed(2) / 100, b, c)) }, paintItems: function () { var b, c, d, a = this.getDataLength(); for (d = 0; a > d; d++) b = this.getX(d), c = this.getY(d), this.paintItem(d, b, c) }, paintEnd: function () { this.ctx.restore() }, getX: function (a) { var c, b = this.options; return "left" == b.align ? 6 : (c = this.ctx.measureText(100 * (this.data[a] / this.level).toFixed(2) / 100).width, b.region.width - c - 10) }, getY: function (a) { var e, b = this.options, d = (this.getDataLength(), this.getItems()); return "MACD" == b.technicalAnalysis || "DMA" == b.technicalAnalysis ? e = -((b.region.height / 2 - b.topAndBottomSpace) / this.maxAbsTechnicalDiff * d[a]) : ("KDJ" == b.technicalAnalysis || "RSI" == b.technicalAnalysis) && (e = -((b.region.height - 2 * b.topAndBottomSpace) / (this.maxTechnicalDiff - this.minTechnicalDiff) * (d[a] - this.minTechnicalDiff)), (e > 0 || e < -b.region.height) && (e = !1)), e }, getItems: function () { return this.data }, getTextColor: function () { } }), xAxis = Painter.extend({ paintStart: function () { var a = this.ctx, b = this.options; a.save(), a.font = b.font, a.translate(b.region.x, b.region.y), a.textBaseline = b.textBaseline }, paintItem: function (a, b, c) { var d = this.ctx; d.fillStyle = this.options.color || this.getTextColor(a), this.ctx.fillText(this.data[a], b, c) }, paintEnd: function () { this.ctx.restore() }, getX: function (a) { var d, b = this.options, c = this.getDataLength(); return 0 == a ? 0 : (d = this.ctx.measureText(this.data[a]).width, a == c - 1 ? b.region.width - d : b.region.width * a / (c - 1) - d / 2) }, getItems: function () { return this.data } }) }(Zepto), function (a) { MinsGraphic = Graphic.extend({ el: "#canvas", options: { maxDots: 241, riseColor: "#d50101", fallColor: "#027e22", normalColor: "#ffffff", equalColor: "#e7a91c", curveChart: { horizontalLineCount: 3, verticalLineCount: 3, middleLineColor: "#2e3741", splitLineColor: "#2e3741", priceLineColor: "#1ca5bc", averageLineColor: "yellow", MountainFillColor: "#1ca5bc", MountainFillAlpha: .3, borderColor: "#2e3741", region: {}, scalerLeft: { font: "20px Helvetica", align: "right", fontHeight: 16, textBaseline: "top", region: {} }, scalerRight: { font: "20px Helvetica", align: "left", fontHeight: 16, textBaseline: "top", region: {} }, scalerTop: { font: "20px Helvetica", color: "white", textBaseline: "top", region: {} }, scalerBottom: { font: "20px Helvetica", color: "white", textBaseline: "top", region: {}, data: ["09:30", "10:30", "11:30/13:00", "14:00", "15:00"] } }, volumeChart: { horizontalLineCount: 1, splitLineColor: "#2e3741", borderColor: "#2e3741", priceLineColor: "white", region: {}, scalerLeft: { font: "20px Helvetica", align: "right", color: "#ffffff", fontHeight: 16, textBaseline: "top", region: {} } } }, pushData: function (b) { var f, g, h, i, c = this.data.items, d = this.options.maxDots || 241, e = b.items; if (a.extend(!0, this.data.stockData, b.stockData), a.isArray(c) && a.isArray(e)) for (g = e.length, h = 0; g > h; h++) i = new Date(Number(e[h].time)), i.getHours() < 10 && i.getMinutes() <= 30 ? c[0] = e[0] : i.getHours() < 11 || i.getHours() < 12 && i.getMinutes() <= 30 ? (f = 60 * (i.getHours() - 9) + i.getMinutes() - 30, c[f] = e[h]) : i.getHours() < 15 ? (f = 60 * (i.getHours() - 13) + i.getMinutes() + 120, c[f] = e[h]) : i.getHours() >= 15 && i.getMinutes() >= 0 && (c[d - 1] = e[h]) }, initialize: function (b) { if (this.el && this.ctx) { var c = this.el, f = { x: 0, y: 0, width: c.width, height: c.height }, g = { width: 100 }, h = { width: b && b.rightRegion || 90 }, i = { height: b.hintChart ? 26 : 4 }, j = { height: 40 }, k = { height: 8 }, l = { x: g.width - .5, y: i.height - .5, width: f.width - g.width - h.width, height: Math.round(2 * ((f.height - i.height - j.height - k.height) / 3)) }, m = { x: l.x, y: i.height + l.height + j.height - .5, width: l.width, height: Math.round(l.height / 2) }; g.x = 0, g.y = i.height, g.height = l.height, h.x = g.width + l.width, h.y = g.y, h.height = g.height, i.x = g.width, i.y = 0, i.width = l.width, j.x = i.x, j.y = i.height + l.height + 6, j.width = i.width, a.extend(!0, this.options.curveChart, { region: l, scalerLeft: { region: g }, scalerRight: { region: h }, scalerTop: { region: i }, scalerBottom: { region: j } }), g.y = m.y, g.height = m.height, a.extend(!0, this.options.volumeChart, { region: m, scalerLeft: { region: g } }), this.initEvents() } }, reSetRegionWidth: function (b) { if (this.el && this.ctx) { var c = this.el, f = { x: 0, y: 0, width: c.width, height: c.height }, g = { width: b.leftRegion || 100 }, h = { width: b.rightRegion || 90 }, i = { height: b.topRegion || 4 }, j = { height: 40 }, k = { height: 8 }, l = { x: g.width - .5, y: i.height - .5, width: f.width - g.width - h.width, height: Math.round(2 * ((f.height - i.height - j.height - k.height) / 3)) }, m = { x: l.x, y: i.height + l.height + j.height - .5, width: l.width, height: Math.round(l.height / 2) }; g.x = 0, g.y = i.height, g.height = l.height, h.x = g.width + l.width, h.y = g.y, h.height = g.height, i.x = g.width, i.y = 0, i.width = l.width, j.x = i.x, j.y = i.height + l.height + 6, j.width = i.width, a.extend(!0, this.options.curveChart, { region: l, scalerLeft: { region: g }, scalerRight: { region: h }, scalerTop: { region: i }, scalerBottom: { region: j } }), g.y = m.y, g.height = m.height, a.extend(!0, this.options.volumeChart, { region: m, scalerLeft: { region: g } }) } }, calRegionsWidth: function () { var h, l, m, i, j, k, p, n, o, q, r, s, t, c = this.ctx, d = this.data, e = this.options, f = e.curveChart; for (f.region, h = new LinePainter(c, a.extend({}, e.curveChart, { maxDots: e.maxDots })), h.data = d, h.setMaxDiff(), i = d.stockData.zs, j = i - h.maxDiff, k = 2 * h.maxDiff / (f.verticalLineCount + 1), n = 0, o = 0, c.font = "20px Helvetica", p = f.verticalLineCount + 1, l = j + p * k, n = c.measureText(l.toFixed(2) + "   ").width, m = 100 * (l - i) / i, o = c.measureText(m.toFixed(2) + "%" + "   ").width, q = 0, r = d.items, s = r.length, t = "", p = 0; s > p; p++) q = Math.max(r[p] ? r[p].volume : 0, q); q / 1e8 > 1 ? (q /= 1e8, t = "亿") : (q /= 1e4, t = "万"), n = Math.max(n, c.measureText(q.toFixed(2) + t + "   ").width), this.reSetRegionWidth({ leftRegion: n, rightRegion: o }), this.options.onRegion && "function" == typeof this.options.onRegion && this.options.onRegion(), h = null }, reSortData: function (b) { var f, g, h, c, d, e, i; if (this.data || (this.data = {}), this.data.stockData || (this.data.stockData = {}), this.data.items || (this.data.items = []), c = this.data.items, d = this.options.maxDots || 241, e = b.items, a.extend(!0, this.data.stockData, b.stockData), a.isArray(c) && a.isArray(e)) for (h = e.length, i = 0; h > i; i++) g = new Date(Number(e[i].time)), g.getHours() < 10 && g.getMinutes() <= 30 ? c[0] = e[i] : g.getHours() < 11 || g.getHours() < 12 && g.getMinutes() <= 30 ? (f = 60 * (g.getHours() - 9) + g.getMinutes() - 30, c[f] = e[i]) : g.getHours() < 15 ? (f = 60 * (g.getHours() - 13) + g.getMinutes() + 120, c[f] = e[i]) : g.getHours() >= 15 && g.getMinutes() >= 0 && (c[d - 1] = e[i]) }, render: function (a) { this.ctx.clearRect(0, 0, this.el.width, this.el.height), this.ctx.canvas.width = this.ctx.canvas.width, a && this.reSortData(a), this.paintTicketHead(), this.ctx && this.data && this.data.items && (this.paintCurveChart(), this.paintVolumeChart(), this.options.onFilish && "function" == typeof this.options.onFilish && this.options.onFilish()) }, refresh: function () { this.ctx && (this.ctx.clearRect(0, 0, this.el.width, this.el.height), this.ctx.canvas.width = this.ctx.canvas.width, this.render()) }, initEvents: function () { }, paintTicketHead: function () { function c(a) { return a && 0 != a ? a : "--" } function d(a, b, c) { return !a || isNaN(a) || !b || isNaN(b) ? a : b - 0 > 0 ? '<font class="rise-color">' + a + (c ? c : "") + "</font>" : 0 > b - 0 ? '<font class="fall-color">' + a + (c ? c : "") + "</font>" : '<font class="normal-color">' + a + (c ? c : "") + "</font>" } var b = this.data.stockData; a(".selectedDetail .jk").html(d(c(b.jk), b.zde)), a(".selectedDetail .zs").html(c(b.zs)), a(".selectedDetail .mc").html(b.mc), a(".selectedDetail .dm").html(b.dm), a(".selectedDetail .zx").html(d(c(b.zx), b.zde)), a(".selectedDetail .zde").html(d(b.zde > 0 ? "+" + b.zde : b.zde < 0 ? b.zde : "--", b.zde)), a(".selectedDetail .zdf").html(d(b.zdf > 0 ? "+" + b.zdf : b.zdf < 0 ? b.zdf : "--", b.zde, "%")), a(".selectedDetail .zd").html(d(c(b.zd), b.zde)), a(".selectedDetail .zg").html(d(c(b.zg), b.zde)), a(".selectedDetail .ze").html(c(b.ze)), a(".selectedDetail .zl").html(c(b.zl)), a(".selectedDetail .hs").html(c(0 == b.hs ? b.hs : "" + b.hs + "%")), a(".selectedDetail .sz").html(c(b.sz)), a(".selectedDetail .gb").html(c(b.gb)), a(".selectedDetail .sy").html(c(b.sy)), a(".selectedDetail .lb").html(c(b.lb)), a(".selectedDetail .jj").html(c(b.jj)), a(".selectedDetail .wb").html(c(0 == b.wb.length || isNaN(b.wb) ? b.wb : "" + b.wb + "%")) }, paintCurveChart: function () { var j, k, l, h, i, m, n, o, u, v, p, q, r, s, t, x, w, c = this.ctx, d = this.data, e = this.options, f = e.curveChart, g = f.region; for (this.calRegionsWidth(), this._paintRect(g.x, g.y, g.width, g.height, f.borderColor), h = (f.horizontalLineCount + f.horizontalLineCount % 2) / 2, i = f.horizontalLineCount + 1, m = 1; m <= f.horizontalLineCount; m++) j = m == h ? f.middleLineColor : f.splitLineColor, l = g.y + Math.round(g.height * m / i), this._paintLine(g.x, l, g.x + g.width, l, j); for (i = f.verticalLineCount + 1, m = 1; m <= f.verticalLineCount; m++) k = g.x + Math.round(g.width * m / i), this._paintLine(k, g.y, k, g.y + g.height, f.splitLineColor); for (n = new AverageLinePainter(c, a.extend({}, e.curveChart, { maxDots: e.maxDots, priceLineColor: "#DA298C" })), o = new MountainLinePainter(c, a.extend({}, e.curveChart, { maxDots: e.maxDots })), n.paint(d), o.paint(d), p = d.stockData.zs, q = [], r = [], s = p - o.maxDiff, t = 2 * o.maxDiff / (f.verticalLineCount + 1), m = f.verticalLineCount + 1; m >= 0; m--) u = s + m * t, q.push(u.toFixed(2)), v = 100 * (u - p) / p, r.push(v.toFixed(2) + "%"); w = { riseColor: e.riseColor, fallColor: e.fallColor, normalColor: e.normalColor }, x = new yAxis(c, a.extend({}, f.scalerLeft, w)), x.paint(q), x = new yAxis(c, a.extend({}, f.scalerRight, w)), x.paint(r), x = new xAxis(c, a.extend({}, f.scalerBottom, w)), x.paint(f.scalerBottom.data) }, _paintRect: function (a, b, c, d, e) { var f = this.ctx; f.beginPath(), f.strokeStyle = e, f.rect(a, b, c, d), f.stroke() }, _paintLine: function (a, b, c, d, e) { var f = this.ctx; f.beginPath(), f.globalAlpha = .5, e && (f.strokeStyle = e), f.moveTo(a, b), f.lineTo(c, d), f.stroke(), f.globalAlpha = 1 }, paintVolumeChart: function () { var j, i, k, l, n, o, m, c = this.ctx, d = this.data, e = this.options, f = e.volumeChart, g = f.region; for (this._paintRect(g.x, g.y, g.width, g.height, f.borderColor), (f.horizontalLineCount + f.horizontalLineCount % 2) / 2, i = f.horizontalLineCount + 1, k = 1; k <= f.horizontalLineCount; k++) j = Math.round(g.y + g.height * k / i) + .5, this._paintLine(g.x, j, g.x + g.width, j, f.splitLineColor); l = new VolumePainter(c, a.extend({}, f, { maxDots: e.maxDots, riseColor: e.riseColor, fallColor: e.fallColor, equalColor: e.equalColor })), l.paint(d), m = l.maxVolume, m / 1e8 > 1 ? (m /= 1e8, n = "亿") : (m /= 1e4, n = "万"), o = new yAxis(c, f.scalerLeft), o.paint([m.toFixed(2), (m / 2).toFixed(2), "(" + n + ")"]) } }) }(Zepto), function (a) {
    var b = 20, d = function (a, b, c) { var f, d = 3, e = [12, 26, 9]; for (b.MACD = [], f = 0; d > f; f++) b.MACD.push(this.Float_LIMIT_VALUE); this.DI = (this.getHigh(c) + this.getLow(c) + 2 * this.getClose(c)) / 4, a < e[0] - 1 ? this.AX += this.DI : a == e[0] - 1 ? (this.AX += this.DI, this.AX /= e[0]) : this.AX = 1538 * (this.DI - this.AX) / 1e4 + this.AX, a < e[1] - 1 ? this.BX += this.DI : a == e[1] - 1 ? (this.BX += this.DI, this.BX /= e[1], this.CX = this.AX - this.BX, b.MACD[0] = this.CX * this.lfMul) : (this.BX = 741 * (this.DI - this.BX) / 1e4 + this.BX, b.MACD[0] = (this.AX - this.BX) * this.lfMul, a < e[1] - 1 + e[2] - 1 ? this.CX += this.AX - this.BX : a == e[1] - 1 + e[2] - 1 ? (this.CX += this.AX - this.BX, this.CX /= e[2], b.MACD[1] = this.CX * this.lfMul, b.MACD[2] = 2 * (this.AX - this.BX - this.CX) * this.lfMul) : (this.CX = 2 * (this.AX - this.BX - this.CX) / 10 + this.CX, b.MACD[1] = this.CX * this.lfMul, b.MACD[2] = 2 * (this.AX - this.BX - this.CX) * this.lfMul)) }, e = function (a, b, c) { var f, d = 3, e = [9]; for (b.KDJ = [], f = 0; d > f; f++) b.KDJ.push(this.Float_LIMIT_VALUE); if (a < e[0] - 1); else if (a == e[0] - 1) b.KDJ[0] = 5e3, b.KDJ[1] = 5e3, b.KDJ[2] = 3 * b.KDJ[1] - 2 * b.KDJ[0]; else { for (j = c + 1 - e[0]; c >= j; j++) j == c + 1 - e[0] ? (dMax = this.getHigh(j), dMin = this.getLow(j)) : (dMax < this.getHigh(j) && (dMax = this.getHigh(j)), dMin > this.getLow(j) && (dMin = this.getLow(j))); dRSV = 0 != dMax - dMin ? 1e4 * (this.getClose(c) - dMin) / (dMax - dMin) : 0, b.KDJ[0] = (2 * this.data.items[a - 1].KDJ[0] + dRSV) / 3 << 0, b.KDJ[1] = (b.KDJ[0] + 2 * this.data.items[a - 1].KDJ[1]) / 3 << 0, b.KDJ[2] = 3 * b.KDJ[0] - 2 * b.KDJ[1] << 0 } }, f = function (a, b, c) { var f, g, k, d = 2, e = [6, 12, 24]; for (b.RSI = [], f = 0; d > f; f++) b.RSI.push(this.Float_LIMIT_VALUE); 0 != c && (g = this.getClose(c), this.getOpen(c), this.getHigh(c), this.getLow(c), k = this.getClose(c - 1), this.getOpen(c - 1), this.getHigh(c - 1), this.getLow(c - 1), c < e[0] ? g > k ? this.upsum1 += g - k : k > g && (this.downsum1 += k - g) : c == e[0] ? (g > k ? this.upsum1 += g - k : k > g && (this.downsum1 += k - g), AX1 = 10 * this.upsum1 / e[0], BX1 = 10 * this.downsum1 / e[0], b.RSI[0] = 0 != AX1 + BX1 ? (1e3 * this.upsum1 / (this.upsum1 + this.downsum1) / 10 << 0) * this.lfMul : 0) : (g > k ? (AX1 = AX1 * (e[0] - 1) + 10 * (g - k), BX1 *= e[0] - 1) : k > g ? (AX1 *= e[0] - 1, BX1 = BX1 * (e[0] - 1) + 10 * (k - g)) : (AX1 *= e[0] - 1, BX1 *= e[0] - 1), AX1 /= e[0], BX1 /= e[0], b.RSI[0] = 0 != AX1 + BX1 ? (1e3 * AX1 / (AX1 + BX1) / 10 << 0) * this.lfMul : 0), c < e[1] ? g > k ? this.upsum2 += g - k : k > g && (this.downsum2 += k - g) : c == e[1] ? (g > k ? this.upsum2 += g - k : k > g && (this.downsum2 += k - g), AX2 = 10 * this.upsum2 / e[1], BX2 = 10 * this.downsum2 / e[1], b.RSI[1] = 0 != AX2 + BX2 ? (1e3 * this.upsum2 / (this.upsum2 + this.downsum2) << 0) / 10 * this.lfMul : 0) : (g > k ? (AX2 = AX2 * (e[1] - 1) + 10 * (g - k), BX2 *= e[1] - 1) : k > g ? (AX2 *= e[1] - 1, BX2 = BX2 * (e[1] - 1) + 10 * (k - g)) : (AX2 *= e[1] - 1, BX2 *= e[1] - 1), AX2 /= e[1], BX2 /= e[1], b.RSI[1] = 0 != AX2 + BX2 ? (1e3 * AX2 / (AX2 + BX2) / 10 << 0) * this.lfMul : 0), c < e[2] ? g > k ? this.upsum3 += g - k : k > g && (this.downsum3 += k - g) : c == e[2] ? (g > k ? this.upsum3 += g - k : k > g && (this.downsum3 += k - g), AX3 = 10 * this.upsum3 / e[2], BX3 = 10 * this.downsum3 / e[2], b.RSI[2] = 0 != AX3 + BX3 ? (1e3 * this.upsum3 / (this.upsum3 + this.downsum3) << 0) / 10 * this.lfMul : 0) : (g > k ? (AX3 = AX3 * (e[2] - 1) + 10 * (g - k), BX3 *= e[2] - 1) : k > g ? (AX3 *= e[2] - 1, BX3 = BX3 * (e[2] - 1) + 10 * (k - g)) : (AX3 *= e[2] - 1, BX3 *= e[2] - 1), AX3 /= e[2], BX3 /= e[2], b.RSI[2] = 0 != AX3 + BX3 ? (1e3 * AX3 / (AX3 + BX3) / 10 << 0) * this.lfMul : 0)) }, g = function (a, b, c) { var f, g, h, i, d = 2, e = [10, 50]; for (b.DMA = [], f = 0; d > f; f++) b.DMA.push(this.Float_LIMIT_VALUE); if (g = 0, h = 0, !(a < e[1] - 1)) { for (i = c - e[0] + 1; c >= i; i++) g += this.getClose(i); for (i = c - e[1] + 1; c >= i; i++) h += this.getClose(i); if (b.DMA[0] = (g / e[0] - h / e[1] << 0) * this.lfMul, a < e[0] + e[1] - 2); else { for (g = 0, i = 0; i < e[0]; i++) g += this.data.items[a - i].DMA[0] / this.lfMul; b.DMA[1] = g / e[0] * this.lfMul << 0 } } }, h = null, i = function (a, b) { var c, d; for (c in a[b]) d = a[b][c] == h ? 0 : a[b][c], this.maxAbsTechnicalDiff = Math.max(Math.abs(d), this.maxAbsTechnicalDiff), this.maxTechnicalDiff = Math.max(d, this.maxTechnicalDiff), this.minTechnicalDiff = Math.min(d, this.minTechnicalDiff) }; KGraphic = MinsGraphic.extend({
        options: { splitSpace: 2, KLineSingleWidth: 10, riseColor: "#d50101", fallColor: "#027e22", equalColor: "#e7a91c", normalColor: "white", technicalAnalysis: "VOL", period: "day", curveChart: { horizontalLineCount: 3, verticalLineCount: 3, middleLineColor: "#2e3741", splitLineColor: "#2e3741", priceLineColor: "blue", borderColor: "#2e3741", region: {}, scalerLeft: { font: "20px Helvetica", align: "right", color: "#ffffff", fontHeight: 16, textBaseline: "top", region: {} }, scalerRight: { font: "20px Helvetica", align: "right", fontHeight: 16, textBaseline: "top", region: {} }, scalerTop: { font: "20px Helvetica", color: "white", textBaseline: "top", region: {} }, scalerBottom: { font: "20px Helvetica", color: "white", textBaseline: "top", region: {}, data: ["", ""] } }, volumeChart: { horizontalLineCount: 1, splitLineColor: "#2e3741", borderColor: "#2e3741", priceLineColor: "white", region: {}, scalerLeft: { font: "20px Helvetica", align: "right", color: "#ffffff", fontHeight: 16, textBaseline: "top", region: {} } }, technicalChart: { splitLineColor: "#2e3741", borderColor: "#2e3741", curveLineColor1: "white", curveLineColor2: "yellow", curveLineColor3: "purple", topAndBottomSpace: 10, region: {}, scalerLeft: { font: "20px Helvetica", align: "right", color: "#ffffff", fontHeight: 16, textBaseline: "middle", region: {} } } }, initialize: function (b) { if (this.el && this.ctx) { var c = this.el, f = { x: 0, y: 0, width: c.width, height: c.height }, g = { width: 100 }, h = { width: b && b.rightRegion || 90 }, i = { height: b.hintChart ? 26 : 4 }, j = { height: 40 }, k = { height: 8 }, l = { x: g.width - .5, y: i.height - .5, width: f.width - g.width - h.width, height: Math.round(2 * ((f.height - i.height - j.height - k.height) / 3)) }, m = { x: l.x, y: i.height + l.height + j.height - .5, width: l.width, height: Math.round(l.height / 2) }, n = { x: l.x, y: i.height + l.height + j.height - .5, width: l.width, height: Math.round(l.height / 2) }; b.technical && (this.options.technicalAnalysis = b.technical), g.x = 0, g.y = i.height, g.height = l.height, h.x = g.width + l.width, h.y = g.y, h.height = g.height, i.x = g.width, i.y = 0, i.width = l.width, j.x = i.x, j.y = i.height + l.height + 6, j.width = i.width, a.extend(!0, this.options.curveChart, { region: l, scalerLeft: { region: g }, scalerRight: { region: h }, scalerTop: { region: i }, scalerBottom: { region: j } }), g.y = m.y, g.height = m.height, a.extend(!0, this.options.volumeChart, { region: m, scalerLeft: { region: g } }), a.extend(!0, this.options.technicalChart, { region: n, scalerLeft: { region: g } }), this.initEvents() } }, popData: function (a) { var d, c = (this.options, this.data.items), e = a && new Date(Number(a)) || null; if (e && c) for (; c.length > 0 && (d = new Date(Number(c[c.length - 1].time)), d.getFullYear() == e.getFullYear() && d.getMonth() == e.getMonth() && d.getDate() == e.getDate()) ;) c.pop() }, pushData: function (b) { var f, g, c = this.data.items, d = c && c.length, e = b.items; if (a.extend(!0, this.data.stockData, b.stockData), a.isArray(c) && a.isArray(e) && (f = e.length, f > 0 && d >= 0)) for (g in e) c.push(e[g]) }, Calcu: function () { var c, h, i, j, a = this, b = 0; this.getClose = function (b) { return Number(a.data.items[b].close) }, this.getOpen = function (b) { return Number(a.data.items[b].open) }, this.getHigh = function (b) { return Number(a.data.items[b].high) }, this.getLow = function (b) { return Number(a.data.items[b].low) }, this.Float_LIMIT_VALUE = null, this.lfMul = 1e3, c = ["upsum1", "downsum1", "upsum2", "downsum2", "upsum3", "downsum3", "AX", "BX", "CX", "DI", "AX1", "BX1", "AX2", "BX2", "AX3", "BX3", "dMax", "dMin", "dRSV", "j"]; for (h in c) this[c[h]] = 0; for (i = b; i <= this.data.items.length; i++) this.data.items[i] && (j = i - b, d.call(this, j, this.data.items[i], i), e.call(this, j, this.data.items[i], i), f.call(this, j, this.data.items[i], i), g.call(this, j, this.data.items[i], i)); for (h in c) this[c[h]] = null, delete this[c[h]]; this.isCalcu = !0 }, render: function (b) {
            var c, d, e, f, g, h, i, j, k; this.ctx.clearRect(0, 0, this.el.width, this.el.height), this.ctx.canvas.width = this.ctx.canvas.width, j = this.options, b && (this.data = b), this.data && this.data.items && this.Calcu(), this.calRegionsWidth(), k = new CandlePainter({}, a.extend({}, j.curveChart, { splitSpace: j.splitSpace, width: j.KLineSingleWidth })), i = k.getMaxPaintItemsLength(), k = null, h = this.data.items.length - i, h = 0 > h ? 0 : h, c = this.data.items[h], d = new Date(Number(c.time)), c = this.data.items[this.data.items.length - 1], f = new Date(Number(c.time)), "5min" == j.period || "15min" == j.period || "30min" == j.period || "60min" == j.period ? (e = d.getFullYear() + "/" + (d.getMonth() + 1) + "/" + d.getDate() + " " + d.getHours() + ":" + d.getMinutes(), g = f.getFullYear() + "/" + (f.getMonth() + 1) + "/" + f.getDate() + " " + f.getHours() + ":" + f.getMinutes()) : (e = d.getFullYear() + "/" + (d.getMonth() + 1) + "/" + d.getDate(), g = f.getFullYear() + "/" + (f.getMonth() + 1) + "/" + f.getDate()), this.options.curveChart.scalerBottom.data = [e, g], this.paintTicketHead(), this.ctx && this.data && this.data.items && (this.paintCurveChart(), this.paintTechnicalChart(), this.options.onFilish && "function" == typeof this.options.onFilish && this.options.onFilish())
        }, paintHintChart: function () { var b = this.ctx, c = this.options, d = this.data && this.data.items || [0], e = c.curveChart, f = e.region; b.font = "20px Helvetica", b.textBaseline = "middle", b.fillStyle = "white", b.fillText("MA5:" + (d[d.length - 1].MA5.toFixed(2) || 0), f.x, f.y - 10), b.fillStyle = "#008cff", b.fillText("MA10:" + (d[d.length - 1].MA10.toFixed(2) || 0), f.x + f.width / 2 - b.measureText("MA10:" + (d[d.length - 1].MA10.toFixed(2) || 0)).width / 2, f.y - 10), b.fillStyle = "#c047de", b.fillText("MA20:" + (d[d.length - 1].MA20.toFixed(2) || 0), f.x + f.width - b.measureText("MA20:" + (d[d.length - 1].MA20.toFixed(2) || 0)).width, f.y - 10) }, reSetRegionWidth: function (b) { if (this.el && this.ctx) { var c = this.el, f = { x: 0, y: 0, width: c.width, height: c.height }, g = { width: b.leftRegion || 100 }, h = { width: b.rightRegion || 90 }, i = { height: b.topRegion || 4 }, j = { height: 40 }, k = { height: 8 }, l = { x: g.width - .5, y: i.height - .5, width: f.width - g.width - h.width, height: Math.round(2 * ((f.height - i.height - j.height - k.height) / 3)) }, m = { x: l.x, y: i.height + l.height + j.height - .5, width: l.width, height: Math.round(l.height / 2) }, n = { x: l.x, y: i.height + l.height + j.height - .5, width: l.width, height: Math.round(l.height / 2) }; g.x = 0, g.y = i.height, g.height = l.height, h.x = g.width + l.width, h.y = g.y, h.height = g.height, i.x = g.width, i.y = 0, i.width = l.width, j.x = i.x, j.y = i.height + l.height + 6, j.width = i.width, a.extend(!0, this.options.curveChart, { region: l, scalerLeft: { region: g }, scalerRight: { region: h }, scalerTop: { region: i }, scalerBottom: { region: j } }), g.y = m.y, g.height = m.height, a.extend(!0, this.options.volumeChart, { region: m, scalerLeft: { region: g } }), a.extend(!0, this.options.technicalChart, { region: n, scalerLeft: { region: g } }) } }, calRegionsWidth: function () { var k, p, q, r, s, t, u, v, c = this, d = this.ctx, e = this.data, f = this.options, g = f.curveChart, h = 0, j = 0, m = 0, n = 0, o = new CandlePainter(d, a.extend({}, { region: { width: c.el.width, height: c.el.height }, splitSpace: f.splitSpace, width: f.KLineSingleWidth })); if (m = o.getMaxPaintItemsLength(), o.data = e, o.setDiff(), h = o.minDiff, j = (o.maxDiff - o.minDiff) / (g.verticalLineCount + 1), p = 0, q = 26, d.font = "20px Helvetica", k = h + (g.verticalLineCount + 1) * j, p = d.measureText(k.toFixed(2) + "   ").width, r = e.items, s = 0, t = "", u = "KDJ" == f.technicalAnalysis ? 100 : 1e3, this.maxTechnicalDiff = 0, this.maxAbsTechnicalDiff = 0, this.minTechnicalDiff = 0, "VOL" == f.technicalAnalysis) { for (n = r.length - m - b, n = 0 > n ? 0 : n, v = n; v < r.length; v++) s = Math.max(s, Number(r[v].volume) || 0); s / 1e8 > 1 ? (s /= 1e8, t = "亿") : (s /= 1e4, t = "万"), p = Math.max(p, d.measureText(s.toFixed(2) + t).width) } else if ("MACD" == f.technicalAnalysis || "DMA" == f.technicalAnalysis) { for (n = r.length - m, n = 0 > n ? 0 : n, v = n; v < r.length; v++) i.call(c, r[v], f.technicalAnalysis); p = Math.max(p, this.maxAbsTechnicalDiff && d.measureText("-" + parseInt(this.maxAbsTechnicalDiff / u)).width || 0) } else if ("KDJ" == f.technicalAnalysis || "RSI" == f.technicalAnalysis) { for (n = r.length - m, n = 0 > n ? 0 : n, v = n; v < r.length; v++) i.call(c, r[v], f.technicalAnalysis); p = Math.max(p, this.maxAbsTechnicalDiff && d.measureText(parseInt(this.maxAbsTechnicalDiff / u)).width || 0) } this.reSetRegionWidth({ leftRegion: p, topRegion: q, rightRegion: 14 }), this.options.onRegion && "function" == typeof this.options.onRegion && this.options.onRegion(), o = null, delete this.maxTechnicalDiff, delete this.maxAbsTechnicalDiff, delete this.minTechnicalDiff }, paintCurveChart: function () { var j, k, l, h, i, m, n, s, o, q, r, v, u, w, x, y, c = this.ctx, d = this.data, e = this.options, f = e.curveChart, g = f.region; for (this._paintRect(g.x, g.y, g.width, g.height, f.borderColor), h = (f.horizontalLineCount + f.horizontalLineCount % 2) / 2, i = f.horizontalLineCount + 1, m = 1; m <= f.horizontalLineCount; m++) j = m == h ? f.middleLineColor : f.splitLineColor, l = g.y + Math.round(g.height * m / i), this._paintLine(g.x, l, g.x + g.width, l, j); for (i = f.verticalLineCount + 1, m = 1; m <= f.verticalLineCount; m++) k = g.x + Math.round(g.width * m / i), this._paintLine(k, g.y, k, g.y + g.height, f.splitLineColor); for (n = new CandlePainter(c, a.extend({}, e.curveChart, { splitSpace: e.splitSpace, riseColor: e.riseColor, fallColor: e.fallColor, equalColor: e.equalColor, width: e.KLineSingleWidth })), n.paint(d), o = [], q = n.minDiff, r = (n.maxDiff - n.minDiff) / (f.verticalLineCount + 1), m = f.verticalLineCount + 1; m >= 0; m--) s = q + m * r, o.push(s.toFixed(2)); u = { riseColor: e.riseColor, fallColor: e.fallColor, normalColor: e.normalColor }, v = new yAxis(c, a.extend({}, f.scalerLeft, u)), v.paint(o), v = new xAxis(c, f.scalerBottom), v.paint(f.scalerBottom.data), w = new KLinePainter(c, a.extend({}, e.curveChart, { maxDiff: n.maxDiff, minDiff: n.minDiff, splitSpace: e.splitSpace, width: e.KLineSingleWidth, volLineColor: "white", splitDay: 5, priceLine: !0 })), w.paint(d), x = new KLinePainter(c, a.extend({}, e.curveChart, { maxDiff: n.maxDiff, minDiff: n.minDiff, splitSpace: e.splitSpace, width: e.KLineSingleWidth, volLineColor: "#008cff", splitDay: 10, priceLine: !0 })), x.paint(d), y = new KLinePainter(c, a.extend({}, e.curveChart, { maxDiff: n.maxDiff, minDiff: n.minDiff, splitSpace: e.splitSpace, width: e.KLineSingleWidth, volLineColor: "#c047de", splitDay: 20, priceLine: !0 })), y.paint(d), this.paintHintChart() }, paintTechnicalChart: function () { var b = this.options; switch (b.technicalAnalysis) { case "VOL": default: this.paintVolumeLine(); break; case "MACD": this.paintMACDLine(); break; case "KDJ": case "RSI": case "DMA": this.paintTechLine() } }, paintVolumeLine: function () { var j, i, k, l, m, n, p, q, o, c = this.ctx, d = this.data, e = this.options, f = e.volumeChart, g = f.region; for (this._paintRect(g.x, g.y, g.width, g.height, f.borderColor), (f.horizontalLineCount + f.horizontalLineCount % 2) / 2, i = f.horizontalLineCount + 1, k = 1; k <= f.horizontalLineCount; k++) j = Math.round(g.y + g.height * k / i) + .5, this._paintLine(g.x, j, g.x + g.width, j, f.splitLineColor); l = new DealVolumePainter(c, a.extend({}, f, { riseColor: e.riseColor, fallColor: e.fallColor, equalColor: e.equalColor, splitSpace: e.splitSpace, width: e.KLineSingleWidth })), l.paint(d), m = new KLinePainter(c, a.extend({}, f, { maxVolume: l.maxVolume, splitSpace: e.splitSpace, width: e.KLineSingleWidth, volLineColor: "white", splitDay: 5 })), m.paint(d), n = new KLinePainter(c, a.extend({}, f, { maxVolume: l.maxVolume, splitSpace: e.splitSpace, width: e.KLineSingleWidth, volLineColor: "yellow", splitDay: 10 })), n.paint(d), o = l.maxVolume, o / 1e8 > 1 ? (o /= 1e8, p = "亿") : (o /= 1e4, p = "万"), q = new yAxis(c, f.scalerLeft), q.paint([o.toFixed(2), (o / 2).toFixed(2), "(" + p + ")"]) }, paintMACDLine: function () { var k, l, m, n, o, p, q, r, s, b = this, c = this.ctx, d = this.data, e = this.data.items, f = this.options, g = f.curveChart, h = f.technicalChart, j = h.region; for (this._paintRect(j.x, j.y, j.width, j.height, h.borderColor), this.maxTechnicalDiff = 0, this.maxAbsTechnicalDiff = 0, this.minTechnicalDiff = 0, n = new Painter({}, a.extend({}, h, { splitSpace: f.splitSpace, width: f.KLineSingleWidth })), l = n.getMaxPaintItemsLength(), m = e.length - l, m = 0 > m ? 0 : m, o = m; o < e.length; o++) i.call(b, e[o], f.technicalAnalysis); for (this.NearByNum = this._getNearbyNum("MACD", m), k = new yAxisTechnical(c, a.extend({}, h.scalerLeft, { technicalAnalysis: f.technicalAnalysis, maxAbsTechnicalDiff: this.maxAbsTechnicalDiff, topAndBottomSpace: h.topAndBottomSpace })), k.paint(this.NearByNum), o = 0; o < this.NearByNum.length; o++) p = j.y + j.height / 2 - (j.height / 2 - h.topAndBottomSpace) / this.maxAbsTechnicalDiff * this.NearByNum[o], this._paintLine(j.x, p, j.x + j.width, p, h.splitLineColor); for (splitCount = g.verticalLineCount + 1, o = 1; o <= g.verticalLineCount; o++) x = j.x + Math.round(j.width * o / splitCount), this._paintLine(x, j.y, x, j.y + j.height, h.splitLineColor); q = new MACDHistogramPainter(c, a.extend({}, h, { riseColor: f.riseColor, fallColor: f.fallColor, equalColor: f.equalColor, splitSpace: f.splitSpace, width: f.KLineSingleWidth, maxAbsTechnicalDiff: this.maxAbsTechnicalDiff, topAndBottomSpace: h.topAndBottomSpace })), q.paint(d), r = new TechnicalLinePainter(c, a.extend({}, h, { splitSpace: f.splitSpace, width: f.KLineSingleWidth, maxAbsTechnicalDiff: this.maxAbsTechnicalDiff, topAndBottomSpace: h.topAndBottomSpace, technicalAnalysis: f.technicalAnalysis, lineType: 0 })), r.paint(d), s = new TechnicalLinePainter(c, a.extend({}, h, { splitSpace: f.splitSpace, width: f.KLineSingleWidth, maxAbsTechnicalDiff: this.maxAbsTechnicalDiff, topAndBottomSpace: h.topAndBottomSpace, technicalAnalysis: f.technicalAnalysis, lineType: 1 })), s.paint(d) }, paintTechLine: function () { var k, l, m, n, o, p, q, r, s, b = this, c = this.ctx, d = this.data, e = this.data.items, f = this.options, g = f.curveChart, h = f.technicalChart, j = h.region; for (this._paintRect(j.x, j.y, j.width, j.height, h.borderColor), this.maxTechnicalDiff = 0, this.maxAbsTechnicalDiff = 0, this.minTechnicalDiff = 0, n = new Painter({}, a.extend({}, h, { splitSpace: f.splitSpace, width: f.KLineSingleWidth })), l = n.getMaxPaintItemsLength(), m = e.length - l, m = 0 > m ? 0 : m, o = m; o < e.length; o++) i.call(b, e[o], f.technicalAnalysis); for (this.NearByNum = this._getNearbyNum(f.technicalAnalysis, m), k = new yAxisTechnical(c, a.extend({}, h.scalerLeft, { technicalAnalysis: f.technicalAnalysis, maxAbsTechnicalDiff: this.maxAbsTechnicalDiff, maxTechnicalDiff: this.maxTechnicalDiff, minTechnicalDiff: this.minTechnicalDiff, topAndBottomSpace: h.topAndBottomSpace })), k.paint(this.NearByNum), o = 0; o < this.NearByNum.length; o++) p = "DMA" == f.technicalAnalysis ? j.y + j.height / 2 - (j.height / 2 - h.topAndBottomSpace) / this.maxAbsTechnicalDiff * this.NearByNum[o] : j.y + j.height - h.topAndBottomSpace - (j.height - 2 * h.topAndBottomSpace) / (this.maxTechnicalDiff - this.minTechnicalDiff) * (this.NearByNum[o] - this.minTechnicalDiff), this._paintLine(j.x, p, j.x + j.width, p, h.splitLineColor); for (splitCount = g.verticalLineCount + 1, o = 1; o <= g.verticalLineCount; o++) x = j.x + Math.round(j.width * o / splitCount), this._paintLine(x, j.y, x, j.y + j.height, h.splitLineColor); q = new TechnicalLinePainter(c, a.extend({}, h, { splitSpace: f.splitSpace, width: f.KLineSingleWidth, maxAbsTechnicalDiff: this.maxAbsTechnicalDiff, maxTechnicalDiff: this.maxTechnicalDiff, minTechnicalDiff: this.minTechnicalDiff, topAndBottomSpace: h.topAndBottomSpace, technicalAnalysis: f.technicalAnalysis, lineType: 0 })), q.paint(d), r = new TechnicalLinePainter(c, a.extend({}, h, { splitSpace: f.splitSpace, width: f.KLineSingleWidth, maxAbsTechnicalDiff: this.maxAbsTechnicalDiff, maxTechnicalDiff: this.maxTechnicalDiff, minTechnicalDiff: this.minTechnicalDiff, topAndBottomSpace: h.topAndBottomSpace, technicalAnalysis: f.technicalAnalysis, lineType: 1 })), r.paint(d), ("KDJ" == f.technicalAnalysis || "RSI" == f.technicalAnalysis) && (s = new TechnicalLinePainter(c, a.extend({}, h, { splitSpace: f.splitSpace, width: f.KLineSingleWidth, maxAbsTechnicalDiff: this.maxAbsTechnicalDiff, maxTechnicalDiff: this.maxTechnicalDiff, minTechnicalDiff: this.minTechnicalDiff, topAndBottomSpace: h.topAndBottomSpace, technicalAnalysis: f.technicalAnalysis, lineType: 2 })), s.paint(d)) }, _cLimitNow: function (a, b) { var d, e, c = [h, h]; if (this.data.items && !(this.data.items.length <= 0)) { for (d = [], e = b; e < this.data.items.length;) d = this.data.items[e][a] || [], 0 == a ? (c[0] = this._getLimit(d, !0, h), c[1] = this._getLimit(d, !1, h)) : (d = d.concat().concat(c), c[0] = this._getLimit(d, !0, h), c[1] = this._getLimit(d, !1, h)), e++; return c } }, _getLimit: function (a, b, c) { var g, d = b ? Math.max : Math.min, e = [], f = a.length; for (g = 0; f > g; g++) a[g] != c && e.push(a[g]); return e.length < 2 ? c : d.apply(null, e) }, _getNearbyNum: function (a, b) { var e, f, g, h, i, j, k, l, m, n, o, c = [], d = a; if (this.__limits = this._cLimitNow(d, b), "MACD" == d) { if (e = this.__limits[0] > this.__limits[1] && this.__limits[0] > -1 * this.__limits[1] ? this.__limits[0] : this.__limits[1], f = this.__limits[0] < this.__limits[1] && this.__limits[0] > -1 * this.__limits[1] ? this.__limits[0] : this.__limits[1], !e || !f) return []; if (g = 0, h = 1, i = e.toString(), e > 0) if (e > 1) for (g = parseInt(i.toString().substr(0, 1)), j = -1 == i.indexOf(".") ? i.length : 1 * i.indexOf("."), k = 0; j - 1 > k; k++) h = 10 * h; else g = parseInt(i.substr(2, 1)), h = .1; else if (e > -1) g = parseInt(i.substr(3, 1)), h = -.1; else for (g = parseInt(i.substr(1, 1)), h = -1, l = -1 == i.indexOf(".") ? i.length - 1 : 1 * i.indexOf(".") - 1, m = 0; l - 1 > m; m++) h = 10 * h; n = 0, o = 0, g >= 8 ? n = 8 : g >= 4 ? n = 4 : g >= 2 ? n = 2 : g >= 1 && (n = 1), n *= h, o = -1 * n > f ? -1 * n : -1 * (n / 2) > f ? -1 * n / 2 : n / 2, c.push(0), c.push(n), c.push(o) } else "RSI" == d ? (c.push(2e4), c.push(5e4), c.push(8e4), c.push(1e5)) : "KDJ" == d ? (c.push(0), c.push(2e3), c.push(5e3), c.push(8e3), c.push(1e4)) : c.push(0); return c }
    })
}(Zepto);