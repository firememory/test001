package org.xvolks.jnative.util.ole;

import org.xvolks.jnative.JNative;
import org.xvolks.jnative.Type;
import org.xvolks.jnative.exceptions.NativeException;
import org.xvolks.jnative.logging.JNativeLogger.SEVERITY;
import org.xvolks.jnative.misc.basicStructures.DWORD;
import org.xvolks.jnative.misc.basicStructures.HRESULT;
import org.xvolks.jnative.misc.basicStructures.LONG;
import org.xvolks.jnative.pointers.Pointer;
import org.xvolks.jnative.pointers.memory.MemoryBlockFactory;
import org.xvolks.jnative.pointers.memory.NativeMemoryBlock;
import org.xvolks.jnative.toolkit.StringToolkit;
import org.xvolks.jnative.util.windows.structures.GUID;

/**
 *
 * $Id: Ole32.java,v 1.8 2008/10/23 14:31:49 mdenty Exp $
 *
 * This software is released under the LGPL.
 * @author Created by Marc DENTY - (c) 2007 JNative project
 */
public class Ole32
{
	public static enum CLSCTX {
		CLSCTX_INPROC_SERVER(1),
		CLSCTX_INPROC_HANDLER(2),
		CLSCTX_LOCAL_SERVER(4),
		CLSCTX_INPROC_SERVER16(8),
		CLSCTX_REMOTE_SERVER(16),
		;
		private final int value;
		private CLSCTX(int value) {
			this.value = value;
		}
		public int getValue() {
			return value;
		}
	} 
	public static final DWORD CLSCTX_ALL = new DWORD(
			CLSCTX.CLSCTX_INPROC_SERVER.getValue()|
			CLSCTX.CLSCTX_INPROC_HANDLER.getValue()|
			CLSCTX.CLSCTX_LOCAL_SERVER.getValue());
	public static final DWORD CLSCTX_INPROC = new DWORD(
			CLSCTX.CLSCTX_INPROC_SERVER.getValue()|
			CLSCTX.CLSCTX_INPROC_HANDLER.getValue());
	public static final DWORD CLSCTX_SERVER = new DWORD(
			CLSCTX.CLSCTX_INPROC_SERVER.getValue()|
			CLSCTX.CLSCTX_LOCAL_SERVER.getValue()|
			CLSCTX.CLSCTX_REMOTE_SERVER.getValue());
	
	public static final String DLL_NAME = "ole32.dll";
    /**
     * <h3>CLSIDFromString</h3>
     * <pre>
     *
     
     Converts a string generated by the StringFromCLSID function back into the original CLSID.
     
     HRESULT CLSIDFromString(
     LPOLESTR lpsz,
     LPCLSID pclsid
     );
     
     ParametersParameters
     
     lpsz
     
     [in] Pointer to the string representation of the CLSID.
     
     pclsid
     
     [out] Pointer to the CLSID on return.
     
     Return ValuesReturn Values
     
     This function supports the standard return value E_INVALIDARG, as well as the following:
     
     NOERROR
     
     The CLSID was obtained successfully.
     
     CO_E_CLASSSTRING
     
     The class string was improperly formatted.
     
     REGDB_E_CLASSNOTREG
     
     The CLSID corresponding to the class string was not found in the registry.
     
     REGDB_E_READREGDB
     
     The registry could not be opened for reading.
     
     RemarksRemarks
     
     Because of the restrictions placed on OLE 1 CLSID values, CLSIDFromProgID and CLSIDFromString are the only two functions that can be used to generate a CLSID for an OLE 1 object.
     </pre>
     * @throws NativeException
     * @throws IllegalAccessException
     */
    public static final GUID CLSIDFromString(String lpsz) throws NativeException, IllegalAccessException
    {
        JNative CLSIDFromString = new JNative(DLL_NAME, "CLSIDFromString");
        CLSIDFromString.setRetVal(Type.INT);
        
        Pointer p = new Pointer(MemoryBlockFactory.createMemoryBlock(16));
        Pointer bstr = Oleaut32.SysAllocString(lpsz);
        CLSIDFromString.setParameter(0, bstr);
        CLSIDFromString.setParameter(1, p);
        CLSIDFromString.invoke();
        int ret = CLSIDFromString.getRetValAsInt();
        if(ret != 0)
        {
            JNative.getLogger().log(SEVERITY.DEBUG, "CLSIDFromString returned "+ret);
        }
        final GUID guid = new GUID();
        guid.setValue(p.getMemory(), 0);
        return guid;
    }
    
    public static final GUID CLSIDFromProgID(String lpsz) throws NativeException, IllegalAccessException
    {
        JNative CLSIDFromString = new JNative(DLL_NAME, "CLSIDFromProgID");
        CLSIDFromString.setRetVal(Type.INT);
        
        Pointer p = new Pointer(MemoryBlockFactory.createMemoryBlock(16));
        Pointer bstr = Oleaut32.SysAllocString(lpsz);
        if(bstr == null) {
        	throw new NativeException("Can't allocate BSTR string");
        } else {
        	System.err.println(StringToolkit.toHexString(bstr.getMemory()));
        }
        CLSIDFromString.setParameter(0, bstr);
        CLSIDFromString.setParameter(1, p);
        Pointer pp = new Pointer(new NativeMemoryBlock(bstr.getPointer()-4, 4+lpsz.length()*2));
        System.err.println(StringToolkit.toHexString(pp.getMemory()));
        CLSIDFromString.invoke();
        int ret = CLSIDFromString.getRetValAsInt();
        if(ret != 0)
        {
            JNative.getLogger().log(SEVERITY.DEBUG, "CLSIDFromString returned "+ret);
            return null;
        }
        final GUID guid = new GUID();
        guid.setValue(p.getMemory(), 0);
        return guid;
        
    }

    public static final HRESULT CoInitialize() throws NativeException, IllegalAccessException {
    	JNative CoInitialize = new JNative(DLL_NAME, "CoInitialize");
    	CoInitialize.setRetVal(Type.INT);
    	CoInitialize.setParameter(0, 0);
    	CoInitialize.invoke();
    	return new HRESULT(CoInitialize.getRetValAsInt());
    }

    /**
     * CoCreateInstance
     * <pre>
     * Creates a single uninitialized object of the class associated with a specified CLSID. 
     * Call CoCreateInstance when you want to create only one object on the local system. 
     * To create a single object on a remote system, call CoCreateInstanceEx, 
     * as CoCreateInstance requires that the HKCR\APPID\{appid}\RemoteServerName key be set to 
     * specify where remote activation of the object must occur.
     * To create multiple objects based on a single CLSID, refer to the CoGetClassObject function.

STDAPI CoCreateInstance(
  REFCLSID rclsid,
  LPUNKNOWN pUnkOuter,
  DWORD dwClsContext,
  REFIID riid,
  LPVOID * ppv
);
 Parameters
rclsid

[in] CLSID associated with the data and code that will be used to create the object.
pUnkOuter

[in] If NULL, indicates that the object is not being created as part of an aggregate. If non-NULL, pointer to the aggregate object's IUnknown interface (the controlling IUnknown).
dwClsContext

[in] Context in which the code that manages the newly created object will run. The values are taken from the enumeration CLSCTX.
riid

[in] Reference to the identifier of the interface to be used to communicate with the object.
ppv

[out] Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppv contains the requested interface pointer. Upon failure, *ppv contains NULL.
</pre>
     * @param rclsid
     * @param pUnkOuter
     * @param dwClsContext
     * @param riid
     * @return
     * @throws NativeException
     * @throws IllegalAccessException
     */
    public static final Pointer CoCreateInstance(
									    		  GUID rclsid,
									    		  Pointer pUnkOuter,
									    		  DWORD dwClsContext,
									    		  GUID riid
    		) throws NativeException, IllegalAccessException {
    	JNative CoCreateInstance = new JNative(DLL_NAME, "CoCreateInstance");
    	CoCreateInstance.setRetVal(Type.INT);
    	int pos = 0;
    	LONG ppIUnknown = new LONG(0);
    	CoCreateInstance.setParameter(pos++, rclsid.getPointer());
    	CoCreateInstance.setParameter(pos++, pUnkOuter);
    	CoCreateInstance.setParameter(pos++, dwClsContext.getValue());
    	CoCreateInstance.setParameter(pos++, riid.getPointer());
    	CoCreateInstance.setParameter(pos++, ppIUnknown.getPointer());
    	CoCreateInstance.invoke();
    	return ppIUnknown.getPointer();
    }
    
}
